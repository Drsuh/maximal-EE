%This Matlab script can be used to generate Figure 2 in the article:
%
%Emil Bjornson, Luca Sanguinetti, Marios Kountouris, "Deploying Dense
%Networks for Maximal Energy Efficiency: Small Cells Meet Massive MIMO,"
%IEEE Journal on Selected Areas in Communications, to appear.
%
%Download article: http://arxiv.org/pdf/1505.01181.pdf
%
%This is version 1.0 (Last edited: 2016-01-04)
%
%License: This code is licensed under the GPLv2 license. If you in any way
%use this code for research that results in publications, please cite our
%original article listed above.
%
%Please note that the channels are generated randomly, thus the results
%will not be exactly the same as in the paper.


%Initialization
close all;
clear all;

%Load Monte-Carlo simulated realizations (these are generated by the script
%generateMonteCarlo.m)
load resultsMC.mat;


%%Simulation parameters

%Define the range of lambda values and the number of points to compute
nbrOfLambdas = 200;
lambdaValues = logspace(-1,4,nbrOfLambdas);

%Select the values of log2(1+gamma) that should be considered
rateValues = [1 2 3];

%Propagation parameters
alpha = 3.76; %Pathloss exponent
omegaSigma2 = 1e-7; %Propagation loss multiplied with sigma2 (1e13*1e-20)
tau = 400; %Length of coherence block (in symbols)

%Hardware characterization
eta = 0.39; %Power amplifier efficiency
epsilon = 0.05; %Level of hardware impairments

%Spectral resources
T = 1/(2e7); %Symbol time (based on 20 MHz)

%Energy parameters
A = 1.15e-9; %Power consumed by coding, decoding, and backhaul (in J/bit)
C0 = 10 * T; %Static energy consumption (10 W divided over the symbols)
C1 = 0.1 * T; %Circuit energy per active UE
D0 = 0.2 * T; %Circuit energy per active BS antenna
D1 = 1.56e-10; %Signal processing coefficient


%Maximal number of antennas and users considered in the simulation. These
%numbers need to selected carefully so that the maximal value is not at the
%edge of the considered region.
Mmax = 250;
Kmax = 40;


%Placeholders for storing of simulation results
EE_theory = zeros(nbrOfLambdas,length(rateValues)); %EE for different lambda and gamma values (using theoretical formulas)
EE_montecarlo = zeros(nbrOfLambdas,length(rateValues)); %EE for different lambda and gamma values (using Monte-Carlo simulations)
optimalParameters = zeros(nbrOfLambdas,4,length(rateValues)); %Store optimal parameter values for each point using the theoretical formulas

%Go through all gamma values
for itr = 1:length(rateValues)
    
    %Extract the current gamma value
    gammaval = 2^rateValues(itr) - 1;
    
    %Go through all lambda values
    for n = 1:nbrOfLambdas
        
        %Display simulation progress
        disp(['Theory, Rate ' num2str(itr) ': Lambda ' num2str(n) '/' num2str(nbrOfLambdas)]);
        
        %Extract current lambda value
        lambda = lambdaValues(n);
        
        %Prepare to store the best parameters for each (M,K)-value
        EEtmp = zeros(Mmax,Kmax);
        betatmp = zeros(Mmax,Kmax);
        SNRtmp = zeros(Mmax,Kmax);
        
        %Go through range of K values
        for k = 1:Kmax
            
            %Go through range of M values
            for m = 1:Mmax
                
                %Find the best SNR=rho/sigma2 value by line search (1e6 is selected as
                %maximal value since 1/SNR is negligible at this number).
                [X,EEvalue] = fminbnd(@(x) -EEcomputation(x,lambda,m,k,gammaval,alpha,omegaSigma2,eta,epsilon,tau,A,C0,C1,D0,D1),0,1e6);
                
                %Check if the problem was feasible
                if X>=0 && EEvalue<0
                    
                    %Compute the B1 and B2 from Eq. (18) and Eq. (19)
                    B1 = (4*k/(alpha-2)^2 + (k+m*(1-epsilon^2))/(alpha-1) + 2*(k+1/X)/(alpha-2));
                    B2 = (k+1/X + 2*k/(alpha-2))*(1+1/X) + (1-epsilon^2)*epsilon^2*m;
                    
                    %Compute beta using Eq. (17)
                    beta = B1*gammaval / (m*(1-epsilon^2)^2-B2*gammaval);
                    
                    %If the first constraint in Eq. (21) is satisfied, then
                    %the results are stored.
                    if beta >= 1
                        EEtmp(m,k) = -EEvalue*1e6; %Multiplied with 1e6 due to normalization in EEcomputation()
                        SNRtmp(m,k) = X;
                        betatmp(m,k) = beta;
                    end
                    
                end
                
            end
            
        end
        
        %Find the M and K values that maximize the EE
        [EEmaxM,optM] = max(EEtmp,[],1);
        [EEmax,optK] = max(EEmaxM);
        
        %Store the maximal EE
        EE_theory(n,itr) = EEmax;
        
        %Store the parameter values (M, K, rho and beta) that achieved the
        %maximal EE
        optimalParameters(n,:,itr) = [optM(optK) optK SNRtmp(optM(optK),optK) betatmp(optM(optK),optK) ];
        
    end
    
    
    %Extract the number of Monte-Carlo simulations
    monteCarloRealizations = length(results);
    
    %Go through all lambda values
    for n = 1:nbrOfLambdas
        
        %Display simulation progress
        disp(['Monte-Carlo, Rate ' num2str(itr) ': Lambda ' num2str(n) '/' num2str(nbrOfLambdas)]);
        
        %Extract current lambda value
        lambda = lambdaValues(n);
        
        %Prepare to store the average rate for each Monte-Carlo realization
        averageRate = zeros(monteCarloRealizations,1);
        
        %Extract the optimal parameters from the theoretical part
        m = optimalParameters(n,1,itr);
        k = optimalParameters(n,2,itr);
        SNR = optimalParameters(n,3,itr);
        beta = optimalParameters(n,4,itr);
        
        %Go through all Monte-Carlo realizations
        for r = 1:monteCarloRealizations
            
            %Prepare to store the SINRs
            SINR = zeros(k,results{r}.nbrBSs);
            
            %Go through all the cells
            for j = 1:results{r}.nbrBSs
                
                %Compute the SINRs in accordance to Lemma 3
                SINR(:,j) = (1-epsilon^2)^2*m *ones(k,1) ./ ( (sum(results{r}.interference1(1:k,j)) + 1/SNR)*((results{r}.interference1(1:k,j)-1)/beta+1+1/SNR) + (1-epsilon^2)*m*(results{r}.interference2(1:k,j)/beta-1/beta+epsilon^2));
                
            end
            
            %Compute the average rate over the network
            averageRate(r) = mean(log2(1+SINR(:)));
            
        end
        
        %Compute the ASE and AEC (both normalized by lambda) based on 
        %Eq. (10) and Eq. (12).
        ASE = k *(1-beta*k/tau) * mean(averageRate);
        AEC = ( (1-(beta*k-1)/tau)*(SNR*omegaSigma2/eta)*gamma(alpha/2+1)/(pi*lambda)^(alpha/2) * k + C0 + C1*k + D0*m + D1*m*k) + A*ASE;
        
        %Compute the EE
        EE_montecarlo(n,itr) = ASE/AEC;
        
    end

end


%Plot Figure 2 from the paper
figure(2);
hold on; box on;

for itr = 1:length(rateValues)
    
    plot(lambdaValues,EE_montecarlo(:,itr)/1e6,'r--','LineWidth',1);
    plot(lambdaValues,EE_theory(:,itr)/1e6,'b','LineWidth',1);
    
end

set(gca,'XScale','log');

xlabel('BS density (\lambda) [BS/km^2]')
ylabel('Energy efficiency [Mbit/Joule]');
ylim([0 14]);
legend('Upper bound (Monte-Carlo)','Lower bound (Prop. 1)','Location','SouthEast');
